import 'codemirror/mode/javascript/javascript'
import 'codemirror/mode/apl/apl'
import 'codemirror/mode/asciiarmor/asciiarmor'
import 'codemirror/mode/asn.1/asn.1'
import 'codemirror/mode/asterisk/asterisk'
import 'codemirror/mode/brainfuck/brainfuck'
import 'codemirror/mode/clike/clike'
import 'codemirror/mode/clojure/clojure'
import 'codemirror/mode/cmake/cmake'
import 'codemirror/mode/cobol/cobol'
import 'codemirror/mode/coffeescript/coffeescript'
import 'codemirror/mode/commonlisp/commonlisp'
import 'codemirror/mode/crystal/crystal'
import 'codemirror/mode/css/css'
import 'codemirror/mode/cypher/cypher'
import 'codemirror/mode/d/d'
import 'codemirror/mode/dart/dart'
import 'codemirror/mode/diff/diff'
import 'codemirror/mode/django/django'
import 'codemirror/mode/dockerfile/dockerfile'
import 'codemirror/mode/dtd/dtd'
import 'codemirror/mode/dylan/dylan'
import 'codemirror/mode/ebnf/ebnf'
import 'codemirror/mode/ecl/ecl'
import 'codemirror/mode/eiffel/eiffel'
import 'codemirror/mode/elm/elm'
import 'codemirror/mode/erlang/erlang'
import 'codemirror/mode/factor/factor'
import 'codemirror/mode/fcl/fcl'
import 'codemirror/mode/forth/forth'
import 'codemirror/mode/fortran/fortran'
import 'codemirror/mode/gas/gas'
import 'codemirror/mode/gfm/gfm'
import 'codemirror/mode/gherkin/gherkin'
import 'codemirror/mode/go/go'
import 'codemirror/mode/groovy/groovy'
import 'codemirror/mode/haml/haml'
import 'codemirror/mode/handlebars/handlebars'
import 'codemirror/mode/haskell-literate/haskell-literate'
import 'codemirror/mode/haskell/haskell'
import 'codemirror/mode/haxe/haxe'
import 'codemirror/mode/htmlembedded/htmlembedded'
import 'codemirror/mode/htmlmixed/htmlmixed'
import 'codemirror/mode/http/http'
import 'codemirror/mode/idl/idl'
import 'codemirror/mode/javascript/javascript'
import 'codemirror/mode/jinja2/jinja2'
import 'codemirror/mode/jsx/jsx'
import 'codemirror/mode/julia/julia'
import 'codemirror/mode/livescript/livescript'
import 'codemirror/mode/lua/lua'
import 'codemirror/mode/markdown/markdown'
import 'codemirror/mode/mathematica/mathematica'
import 'codemirror/mode/mbox/mbox'
import 'codemirror/mode/mirc/mirc'
import 'codemirror/mode/mllike/mllike'
import 'codemirror/mode/modelica/modelica'
import 'codemirror/mode/mscgen/mscgen'
import 'codemirror/mode/mumps/mumps'
import 'codemirror/mode/nginx/nginx'
import 'codemirror/mode/nsis/nsis'
import 'codemirror/mode/ntriples/ntriples'
import 'codemirror/mode/octave/octave'
import 'codemirror/mode/oz/oz'
import 'codemirror/mode/pascal/pascal'
import 'codemirror/mode/pegjs/pegjs'
import 'codemirror/mode/perl/perl'
import 'codemirror/mode/php/php'
import 'codemirror/mode/pig/pig'
import 'codemirror/mode/powershell/powershell'
import 'codemirror/mode/properties/properties'
import 'codemirror/mode/protobuf/protobuf'
import 'codemirror/mode/pug/pug'
import 'codemirror/mode/puppet/puppet'
import 'codemirror/mode/python/python'
import 'codemirror/mode/q/q'
import 'codemirror/mode/r/r'
import 'codemirror/mode/rpm/rpm'
import 'codemirror/mode/rst/rst'
import 'codemirror/mode/ruby/ruby'
import 'codemirror/mode/rust/rust'
import 'codemirror/mode/sas/sas'
import 'codemirror/mode/sass/sass'
import 'codemirror/mode/scheme/scheme'
import 'codemirror/mode/shell/shell'
import 'codemirror/mode/sieve/sieve'
import 'codemirror/mode/slim/slim'
import 'codemirror/mode/smalltalk/smalltalk'
import 'codemirror/mode/smarty/smarty'
import 'codemirror/mode/solr/solr'
import 'codemirror/mode/soy/soy'
import 'codemirror/mode/sparql/sparql'
import 'codemirror/mode/spreadsheet/spreadsheet'
import 'codemirror/mode/sql/sql'
import 'codemirror/mode/stex/stex'
import 'codemirror/mode/stylus/stylus'
import 'codemirror/mode/swift/swift'
import 'codemirror/mode/tcl/tcl'
import 'codemirror/mode/textile/textile'
import 'codemirror/mode/tiddlywiki/tiddlywiki'
import 'codemirror/mode/tiki/tiki'
import 'codemirror/mode/toml/toml'
import 'codemirror/mode/tornado/tornado'
import 'codemirror/mode/troff/troff'
import 'codemirror/mode/ttcn-cfg/ttcn-cfg'
import 'codemirror/mode/ttcn/ttcn'
import 'codemirror/mode/turtle/turtle'
import 'codemirror/mode/twig/twig'
import 'codemirror/mode/vb/vb'
import 'codemirror/mode/vbscript/vbscript'
import 'codemirror/mode/velocity/velocity'
import 'codemirror/mode/verilog/verilog'
import 'codemirror/mode/vhdl/vhdl'
import 'codemirror/mode/vue/vue'
import 'codemirror/mode/webidl/webidl'
import 'codemirror/mode/xml/xml'
import 'codemirror/mode/xquery/xquery'
import 'codemirror/mode/yacas/yacas'
import 'codemirror/mode/yaml-frontmatter/yaml-frontmatter'
import 'codemirror/mode/yaml/yaml'
import 'codemirror/mode/z80/z80'
import CodeMirror from 'codemirror'
import {Selection, TextSelection, Plugin, PluginKey} from 'prosemirror-state'
import {Decoration, DecorationSet, EditorView, Node} from 'prosemirror-view'
import {Schema} from 'prosemirror-model'
import {undo, redo} from 'prosemirror-history'
import {exitCode} from 'prosemirror-commands'
import {inputRules, textblockTypeInputRule} from 'prosemirror-inputrules'
import {keymap} from 'prosemirror-keymap'
import prettier from 'prettier'
import parserBabel from 'prettier/parser-babel'
import parserCss from 'prettier/parser-postcss'
import parserHtml from 'prettier/parser-html'
import parserMarkdown from 'prettier/parser-markdown'
import parserYaml from 'prettier/parser-yaml'
import logos from './logos'

const initialState = {
  theme: 'dracula',
  typewriterMode: false,
  fontSize: 18,
}

interface CodeBlockProps {
  theme: string;
  typewriterMode: boolean;
  fontSize: number;
}

const codeBlockPlugin = (props: CodeBlockProps) => new Plugin({
  key: new PluginKey('code-block'),
  state: {
    init: () => ({...initialState, ...props}),
    apply(tr, prev) {
      const meta = tr.getMeta('code-block')
      return meta ? meta : prev
    }
  },
  props: {
    decorations(state) {
      const decos = []
      state.doc.descendants((node, pos) => {
        if (node.type.name === 'code_block') {
          decos.push(Decoration.node(pos, pos + node.nodeSize, this.getState(state)))
        }
      })

      return DecorationSet.create(state.doc, decos)
    }
  }
})

class CodeBlockView {
  node: Node
  view: EditorView
  getPos: () => number
  schema: Schema
  incomingChanges: boolean
  cm: CodeMirror
  dom: Element
  updating: boolean
  clicked: boolean
  options: {[key: string]: unknown}
  logo: HTMLElement
  prettifyBtn: HTMLElement

  constructor(node, view, getPos, schema, decos) {
    // Store for later
    this.node = node
    this.view = view
    this.getPos = getPos
    this.schema = schema
    this.incomingChanges = false
    this.options = {}

    // Create a CodeMirror instance
    this.cm = new CodeMirror(null, {
      value: this.node.textContent,
      extraKeys: this.codeMirrorKeymap(),
      theme: initialState.theme,
      scrollbarStyle: null,
      ...optionsByLang(this.getLang()),
    })

    this.updateOptions(decos)

    this.logo = document.createElement('span')
    this.prettifyBtn = document.createElement('span')
    this.prettifyBtn.className = 'prettify'
    this.prettifyBtn.textContent = 'âœ¨'
    this.prettifyBtn.style.display = 'none'
    this.prettifyBtn.setAttribute('title', 'prettify')
    this.prettifyBtn.addEventListener('click', this.prettify.bind(this))
    this.updateNav()

    const container = document.createElement('div')
    container.className = 'codemirror-container'

    const langInput = document.createElement('span')
    langInput.className = 'lang-input'
    langInput.textContent = this.getLang()
    langInput.setAttribute('contenteditable', '')
    langInput.addEventListener('keydown', (e) => {
      if (e.keyCode === 13) {
        e.preventDefault()
        const lang = cleanLang(langInput.textContent)
        langInput.textContent = lang
        langSelect.style.display = 'none'
        langSelectBottom.style.display = 'none'
        langToggle.style.display = 'block'
        const tr = view.state.tr
        tr.setNodeMarkup(getPos(), undefined, {...this.node.attrs, params: lang})
        view.dispatch(tr)
        this.updateLang()
        this.updateNav()
      }
    })

    langInput.addEventListener('blur', () => {
      langSelect.style.display = 'none'
      langSelectBottom.style.display = 'none'
      langToggle.style.display = 'block'
    })

    const langSelect = document.createElement('div')
    langSelect.className = 'lang-select'
    langSelect.textContent = '```'
    langSelect.style.display = 'none'
    langSelect.appendChild(langInput)
    const langSelectBottom = document.createElement('div')
    langSelectBottom.className = 'lang-select'
    langSelectBottom.textContent = '```'
    langSelectBottom.style.display = 'none'

    const langToggle = document.createElement('div')
    langToggle.className = 'lang-toggle'
    langToggle.appendChild(this.logo)
    langToggle.addEventListener('click', () => {
      langToggle.style.display = 'none'
      langSelect.style.display = 'block'
      langSelectBottom.style.display = 'block'
      langInput.focus()
      const range = document.createRange()
      range.selectNodeContents(langInput)
      const sel = window.getSelection()
      sel.removeAllRanges()
      sel.addRange(range)
    })

    container.appendChild(langSelect)
    container.appendChild(this.cm.getWrapperElement())
    container.appendChild(langSelectBottom)
    container.appendChild(langToggle)
    container.appendChild(this.prettifyBtn)
    this.dom = container

    // CodeMirror needs to be in the DOM to properly initialize, so
    // schedule it to update itself
    setTimeout(() => this.cm.refresh(), 20)

    // This flag is used to avoid an update loop between the outer and
    // inner editor
    this.updating = false

    // To distinguish between clicked selection change and others.
    this.clicked = false

    // Track whether changes are have been made but not yet propagated
    this.cm.on('beforeChange', () => this.incomingChanges = true)
    this.cm.on('mousedown', () => this.clicked = true)

    // Propagate updates from the code editor to ProseMirror
    this.cm.on('cursorActivity', () => {
      if (!this.updating && !this.incomingChanges) {
        this.forwardSelection()
      }
    })

    // Remove the editor if value is empty and backspace
    this.cm.on('keydown', (cm, e) => {
      if (cm.getValue() === '' && e.keyCode === 8) {
        const pos = getPos()
        const tr = view.state.tr.deleteRange(Math.max(0, pos-1), pos+1)
        view.dispatch(tr)
        view.focus()
      }
    })

    this.cm.on('changes', () => {
      if (!this.updating) {
        this.valueChanged()
        this.forwardSelection()
      }
      this.incomingChanges = false
    })

    this.cm.on('focus', () => this.forwardSelection())
  }

  forwardSelection() {
    if (!this.cm.hasFocus()) return
    const state = this.view.state
    const selection = this.asProseMirrorSelection(state.doc)
    if (!selection.eq(state.selection)) {
      this.view.dispatch(state.tr.setSelection(selection))
    }

    if (this.clicked) {
      this.clicked = false
      return
    }

    if (!this.options.typewriterMode || !selection.empty) {
      return
    }

    const coords = this.cm.cursorCoords(this.cm.getCursor())
    const elem = document.elementFromPoint(coords.left, coords.top)
    if (!elem) {
      return
    }

    elem.scrollIntoView({
      block: 'center',
      behavior: 'smooth',
    })
  }

  asProseMirrorSelection(doc) {
    const offset = this.getPos() + 1
    const anchor = this.cm.indexFromPos(this.cm.getCursor('anchor')) + offset
    const head = this.cm.indexFromPos(this.cm.getCursor('head')) + offset
    return TextSelection.create(doc, anchor, head)
  }

  setSelection(anchor, head) {
    this.cm.focus()
    this.updating = true
    this.cm.setSelection(
      this.cm.posFromIndex(anchor),
      this.cm.posFromIndex(head)
    )
    this.updating = false
  }

  valueChanged() {
    const change = computeChange(this.node.textContent, this.cm.getValue())
    if (change) {
      const start = this.getPos() + 1
      const tr = this.view.state.tr.replaceWith(
        start + change.from,
        start + change.to,
        change.text ? this.schema.text(change.text) : null
      )
      this.view.dispatch(tr)
    }
  }

  codeMirrorKeymap() {
    const view = this.view
    const mod = /Mac/.test(navigator.platform) ? 'Cmd' : 'Ctrl'
    return CodeMirror.normalizeKeyMap({
      Up: () => this.maybeEscape('line', -1),
      Left: () => this.maybeEscape('char', -1),
      Down: () => this.maybeEscape('line', 1),
      Right: () => this.maybeEscape('char', 1),
      [`${mod}-Z`]: () => undo(view.state, view.dispatch),
      [`Shift-${mod}-Z`]: () => redo(view.state, view.dispatch),
      [`${mod}-Y`]: () => redo(view.state, view.dispatch),
      'Ctrl-Enter': () => {
        if (exitCode(view.state, view.dispatch)) view.focus()
      }
    })
  }

  maybeEscape(unit, dir) {
    const cursor = this.cm.getCursor()
    if (
      this.cm.somethingSelected() ||
      cursor.line != (dir < 0 ? this.cm.firstLine() : this.cm.lastLine()) ||
      (
        unit == 'char' &&
        cursor.ch != (dir < 0 ? 0 : this.cm.getLine(cursor.line).length)
      )
    ) {
      return CodeMirror.Pass
    }

    this.view.focus()
    const targetPos = this.getPos() + (dir < 0 ? 0 : this.node.nodeSize)
    const tr = this.view.state.tr
    let selection

    if (targetPos === 0) {
      tr.insert(0, this.schema.node('paragraph'))
      selection = new TextSelection(tr.doc.resolve(targetPos))
    } else {
      selection = Selection.near(this.view.state.doc.resolve(targetPos), dir)
    }

    tr.setSelection(selection).scrollIntoView()
    this.view.dispatch(tr)
    this.view.focus()
  }

  update(node, decorations) {
    if (node.type != this.node.type) return false
    this.node = node
    this.updateOptions(decorations)
    this.updateLang()
    this.updateNav()
    const change = computeChange(this.cm.getValue(), node.textContent)
    if (change) {
      this.updating = true
      this.cm.replaceRange(
        change.text,
        this.cm.posFromIndex(change.from),
        this.cm.posFromIndex(change.to)
      )
      this.updating = false
    }
    return true
  }

  updateOptions(decorations) {
    if (decorations?.length) {
      decorations.forEach((deco) => {
        for (const key in deco.type.attrs) {
          const value = deco.type.attrs[key]
          this.options[key] = value
          this.cm.setOption(key, value)
        }

        this.cm.refresh()
      })
    }
  }

  updateLang() {
    const options = optionsByLang(this.getLang())
    const prev = this.cm.getOption('mode')
    if (options.mode !== prev) {
      for (const key in options) {
        this.cm.setOption(key, options[key])
      }
    }
  }

  updateNav() {
    let elem
    if (logos[this.getLang()]) {
      elem = document.createElement('img')
      elem.src = logos[this.getLang()]
      elem.width = this.options.fontSize
      elem.height = this.options.fontSize
      elem.style.marginTop = `${this.options.fontSize as number / 4}px`
    } else {
      elem = document.createElement('span')
      elem.textContent = 'ðŸ“œ'
    }

    if (
      this.getLang() === 'javascript' ||
      this.getLang() === 'typescript' ||
      this.getLang() === 'css' ||
      this.getLang() === 'html' ||
      this.getLang() === 'scss' ||
      this.getLang() === 'less' ||
      this.getLang() === 'markdown' ||
      this.getLang() === 'yaml' ||
      this.getLang() === 'json'
    ) {
      this.prettifyBtn.textContent = 'âœ¨'
      this.prettifyBtn.style.display = 'block'
    } else {
      this.prettifyBtn.style.display = 'none'
    }

    this.logo.innerHTML = ''
    this.logo.appendChild(elem)
  }

  prettify() {
    const lang = this.getLang()

    if (lang === 'json') {
      try {
        const value = JSON.stringify(JSON.parse(this.cm.getValue()), null, 2)
        this.cm.setValue(value)
        this.prettifyBtn.textContent = ''
      } catch (err) {
        this.prettifyBtn.textContent = 'ðŸš¨'
      }
      return
    }

    const [parser, plugin] =
      lang === 'javascript' ? ['babel', parserBabel] :
      lang === 'css' ? ['css', parserCss] :
      lang === 'markdown' ? ['markdown', parserMarkdown] :
      lang === 'html' ? ['html', parserHtml] :
      lang === 'less' ? ['less', parserCss] :
      lang === 'scss' ? ['scss', parserCss] :
      lang === 'yaml' ? ['yaml', parserYaml] :
      lang === 'typescript' ? ['babel', parserBabel] :
      undefined
    if (!parser) return
    try {
      const value = prettier.format(this.cm.getValue(), {
        parser,
        plugins: [plugin],
        semi: false,
        singleQuote: true,
        trailingComma: 'all',
        bracketSpacing: false,
      })

      this.cm.setValue(value.substring(0, value.lastIndexOf('\n')))
      this.prettifyBtn.textContent = ''
    } catch (err) {
      this.prettifyBtn.textContent = 'ðŸš¨'
    }
  }

  getLang() {
    return this.node.attrs.params ?? ''
  }

  selectNode() {
    this.cm.focus()
  }

  stopEvent() {
    return true
  }
}

function computeChange(oldVal, newVal) {
  if (oldVal == newVal) return null
  let start = 0
  let oldEnd = oldVal.length
  let newEnd = newVal.length

  while (
    start < oldEnd &&
    oldVal.charCodeAt(start) == newVal.charCodeAt(start)
  ) {
    ++start
  }

  while (
    oldEnd > start &&
    newEnd > start &&
    oldVal.charCodeAt(oldEnd - 1) == newVal.charCodeAt(newEnd - 1)
  ) {
    oldEnd--
    newEnd--
  }

  return {
    from: start,
    to: oldEnd,
    text: newVal.slice(start, newEnd),
  }
}

function arrowHandler(dir) {
  return (state, dispatch, view) => {
    if (state.selection.empty && view.endOfTextblock(dir)) {
      const side = dir == 'left' || dir == 'up' ? -1 : 1
      const $head = state.selection.$head
      const nextPos = Selection.near(
        state.doc.resolve(side > 0 ? $head.after() : $head.before()),
        side
      )

      if (nextPos.$head?.parent.type.name == 'code_block') {
        dispatch(state.tr.setSelection(nextPos))
        return true
      }
    }
    return false
  }
}

const cleanLang = (lang: string) =>
  lang === 'js' ? 'javascript' :
  lang === 'ts' ? 'typescript' :
  lang === 'cplusplus' ? 'cpp' :
  lang === 'c++' ? 'cpp' :
  lang

const optionsByLang = (lang: string) =>
  lang === 'c' ? {mode: 'text/x-csrc'} :
  lang === 'cplusplus' ? {mode: 'text/x-c++src'} :
  lang === 'cpp' ? {mode: 'text/x-c++src'} :
  lang === 'c++' ? {mode: 'text/x-c++src'} :
  lang === 'objective-c' ? {mode: 'text/x-objectivec'} :
  lang === 'objc' ? {mode: 'text/x-objectivec'} :
  lang === 'scala' ? {mode: 'text/x-scala'} :
  lang === 'kotlin' ? {mode: 'text/x-kotlin'} :
  lang === 'ceylon' ? {mode: 'text/x-ceylon'} :
  lang === 'java' ? {mode: 'text/x-java'} :
  lang === 'typescript' ? {mode: 'javascript'} :
  lang === 'less' ? {mode: 'css'} :
  lang === 'scss' ? {mode: 'css'} :
  lang === 'html' ? {mode: 'xml', htmlMode: true} :
  {mode: lang}

const codeBlockKeymap = {
  ArrowLeft: arrowHandler('left'),
  ArrowRight: arrowHandler('right'),
  ArrowUp: arrowHandler('up'),
  ArrowDown: arrowHandler('down'),
}

const codeBlockRule = (nodeType) =>
  textblockTypeInputRule(
    /^```([a-zA-Z]*)?\s$/,
    nodeType,
    match => {
      const lang = match[1]
      if (lang) return {params: cleanLang(lang)}
      return {}
    }
  )

export default (props: CodeBlockProps) => ({
  plugins: (prev, schema) => [
    ...prev,
    inputRules({rules: [codeBlockRule(schema.nodes.code_block)]}),
    keymap(codeBlockKeymap),
    codeBlockPlugin(props),
  ],
  nodeViews: {
    code_block: (node, view, getPos, decos) => {
      return new CodeBlockView(node, view, getPos, view.state.schema, decos)
    }
  },
})

export const updateOptions = (view: EditorView, options: CodeBlockProps) => {
  const tr = view.state.tr
  tr.setMeta('code-block', options)
  view.dispatch(tr)
}
