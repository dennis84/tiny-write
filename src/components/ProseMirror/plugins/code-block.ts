import 'codemirror/mode/javascript/javascript'
import 'codemirror/mode/apl/apl'
import 'codemirror/mode/asciiarmor/asciiarmor'
import 'codemirror/mode/asn.1/asn.1'
import 'codemirror/mode/asterisk/asterisk'
import 'codemirror/mode/brainfuck/brainfuck'
import 'codemirror/mode/clike/clike'
import 'codemirror/mode/clojure/clojure'
import 'codemirror/mode/cmake/cmake'
import 'codemirror/mode/cobol/cobol'
import 'codemirror/mode/coffeescript/coffeescript'
import 'codemirror/mode/commonlisp/commonlisp'
import 'codemirror/mode/crystal/crystal'
import 'codemirror/mode/css/css'
import 'codemirror/mode/cypher/cypher'
import 'codemirror/mode/d/d'
import 'codemirror/mode/dart/dart'
import 'codemirror/mode/diff/diff'
import 'codemirror/mode/django/django'
import 'codemirror/mode/dockerfile/dockerfile'
import 'codemirror/mode/dtd/dtd'
import 'codemirror/mode/dylan/dylan'
import 'codemirror/mode/ebnf/ebnf'
import 'codemirror/mode/ecl/ecl'
import 'codemirror/mode/eiffel/eiffel'
import 'codemirror/mode/elm/elm'
import 'codemirror/mode/erlang/erlang'
import 'codemirror/mode/factor/factor'
import 'codemirror/mode/fcl/fcl'
import 'codemirror/mode/forth/forth'
import 'codemirror/mode/fortran/fortran'
import 'codemirror/mode/gas/gas'
import 'codemirror/mode/gfm/gfm'
import 'codemirror/mode/gherkin/gherkin'
import 'codemirror/mode/go/go'
import 'codemirror/mode/groovy/groovy'
import 'codemirror/mode/haml/haml'
import 'codemirror/mode/handlebars/handlebars'
import 'codemirror/mode/haskell-literate/haskell-literate'
import 'codemirror/mode/haskell/haskell'
import 'codemirror/mode/haxe/haxe'
import 'codemirror/mode/htmlembedded/htmlembedded'
import 'codemirror/mode/htmlmixed/htmlmixed'
import 'codemirror/mode/http/http'
import 'codemirror/mode/idl/idl'
import 'codemirror/mode/javascript/javascript'
import 'codemirror/mode/jinja2/jinja2'
import 'codemirror/mode/jsx/jsx'
import 'codemirror/mode/julia/julia'
import 'codemirror/mode/livescript/livescript'
import 'codemirror/mode/lua/lua'
import 'codemirror/mode/markdown/markdown'
import 'codemirror/mode/mathematica/mathematica'
import 'codemirror/mode/mbox/mbox'
import 'codemirror/mode/mirc/mirc'
import 'codemirror/mode/mllike/mllike'
import 'codemirror/mode/modelica/modelica'
import 'codemirror/mode/mscgen/mscgen'
import 'codemirror/mode/mumps/mumps'
import 'codemirror/mode/nginx/nginx'
import 'codemirror/mode/nsis/nsis'
import 'codemirror/mode/ntriples/ntriples'
import 'codemirror/mode/octave/octave'
import 'codemirror/mode/oz/oz'
import 'codemirror/mode/pascal/pascal'
import 'codemirror/mode/pegjs/pegjs'
import 'codemirror/mode/perl/perl'
import 'codemirror/mode/php/php'
import 'codemirror/mode/pig/pig'
import 'codemirror/mode/powershell/powershell'
import 'codemirror/mode/properties/properties'
import 'codemirror/mode/protobuf/protobuf'
import 'codemirror/mode/pug/pug'
import 'codemirror/mode/puppet/puppet'
import 'codemirror/mode/python/python'
import 'codemirror/mode/q/q'
import 'codemirror/mode/r/r'
import 'codemirror/mode/rpm/rpm'
import 'codemirror/mode/rst/rst'
import 'codemirror/mode/ruby/ruby'
import 'codemirror/mode/rust/rust'
import 'codemirror/mode/sas/sas'
import 'codemirror/mode/sass/sass'
import 'codemirror/mode/scheme/scheme'
import 'codemirror/mode/shell/shell'
import 'codemirror/mode/sieve/sieve'
import 'codemirror/mode/slim/slim'
import 'codemirror/mode/smalltalk/smalltalk'
import 'codemirror/mode/smarty/smarty'
import 'codemirror/mode/solr/solr'
import 'codemirror/mode/soy/soy'
import 'codemirror/mode/sparql/sparql'
import 'codemirror/mode/spreadsheet/spreadsheet'
import 'codemirror/mode/sql/sql'
import 'codemirror/mode/stex/stex'
import 'codemirror/mode/stylus/stylus'
import 'codemirror/mode/swift/swift'
import 'codemirror/mode/tcl/tcl'
import 'codemirror/mode/textile/textile'
import 'codemirror/mode/tiddlywiki/tiddlywiki'
import 'codemirror/mode/tiki/tiki'
import 'codemirror/mode/toml/toml'
import 'codemirror/mode/tornado/tornado'
import 'codemirror/mode/troff/troff'
import 'codemirror/mode/ttcn-cfg/ttcn-cfg'
import 'codemirror/mode/ttcn/ttcn'
import 'codemirror/mode/turtle/turtle'
import 'codemirror/mode/twig/twig'
import 'codemirror/mode/vb/vb'
import 'codemirror/mode/vbscript/vbscript'
import 'codemirror/mode/velocity/velocity'
import 'codemirror/mode/verilog/verilog'
import 'codemirror/mode/vhdl/vhdl'
import 'codemirror/mode/vue/vue'
import 'codemirror/mode/webidl/webidl'
import 'codemirror/mode/xml/xml'
import 'codemirror/mode/xquery/xquery'
import 'codemirror/mode/yacas/yacas'
import 'codemirror/mode/yaml-frontmatter/yaml-frontmatter'
import 'codemirror/mode/yaml/yaml'
import 'codemirror/mode/z80/z80'
import CodeMirror from 'codemirror'
import {Selection, TextSelection, Plugin, PluginKey} from 'prosemirror-state'
import {Decoration, DecorationSet, EditorView, Node} from 'prosemirror-view'
import {Schema} from 'prosemirror-model'
import {undo, redo} from 'prosemirror-history'
import {exitCode} from 'prosemirror-commands'
import {keymap} from 'prosemirror-keymap'

export const codeBlockOptions = () => new Plugin({
  key: new PluginKey('code-block-options'),
  state: {
    init: () => ({theme: 'dracula'}),
    apply(tr, prev) {
      const meta = tr.getMeta('code-block-options')
      return meta ? meta : prev
    }
  },
  props: {
    decorations(state) {
      const decos = []
      state.doc.descendants((node, pos) => {
        if (node.type.name === 'code_block') {
          decos.push(Decoration.node(pos, pos + node.nodeSize, this.getState(state)))
        }
      })

      return DecorationSet.create(state.doc, decos)
    }
  }
})

export class CodeBlockView {
  node: Node
  view: EditorView
  getPos: () => number
  schema: Schema
  incomingChanges: boolean
  cm: CodeMirror
  dom: Element
  updating: boolean
  clicked: boolean

  constructor(node, view, getPos, schema, decos) {
    // Store for later
    this.node = node
    this.view = view
    this.getPos = getPos
    this.schema = schema
    this.incomingChanges = false

    // Create a CodeMirror instance
    this.cm = new CodeMirror(null, {
      value: this.node.textContent,
      extraKeys: this.codeMirrorKeymap(),
      mode: modeByLang(node.attrs.params ?? 'javascript'),
      theme: 'dracula',
      scrollbarStyle: null,
    })

    this.updateOptions(decos)

    // The editor's outer node is our DOM representation
    this.dom = this.cm.getWrapperElement()

    // CodeMirror needs to be in the DOM to properly initialize, so
    // schedule it to update itself
    setTimeout(() => this.cm.refresh(), 20)

    // This flag is used to avoid an update loop between the outer and
    // inner editor
    this.updating = false

    // To distinguish between clicked selection change and others.
    this.clicked = false

    // Track whether changes are have been made but not yet propagated
    this.cm.on('beforeChange', () => this.incomingChanges = true)
    this.cm.on('mousedown', () => this.clicked = true)

    // Propagate updates from the code editor to ProseMirror
    this.cm.on('cursorActivity', () => {
      if (!this.updating && !this.incomingChanges) {
        this.forwardSelection()
      }
    })

    // Remove the editor if value is empty and backspace
    this.cm.on('keydown', (cm, e) => {
      if (cm.getValue() === '' && e.keyCode === 8) {
        const pos = getPos()
        const tr = view.state.tr.deleteRange(Math.max(0, pos-1), pos+1)
        view.dispatch(tr)
        view.focus()
      }
    })

    this.cm.on('changes', () => {
      if (!this.updating) {
        this.valueChanged()
        this.forwardSelection()
      }
      this.incomingChanges = false
    })

    this.cm.on('focus', () => this.forwardSelection())
  }

  forwardSelection() {
    if (!this.cm.hasFocus()) return
    const state = this.view.state
    const selection = this.asProseMirrorSelection(state.doc)
    if (!selection.eq(state.selection)) {
      this.view.dispatch(state.tr.setSelection(selection))
    }

    if (this.clicked) {
      this.clicked = false
      return
    }

    if (!selection.empty) {
      return
    }

    const coords = this.cm.cursorCoords(this.cm.getCursor())
    const elem = document.elementFromPoint(coords.left, coords.top)
    if (!elem) {
      return
    }

    elem.scrollIntoView({
      block: 'center',
      behavior: 'smooth',
    })
  }

  asProseMirrorSelection(doc) {
    const offset = this.getPos() + 1
    const anchor = this.cm.indexFromPos(this.cm.getCursor('anchor')) + offset
    const head = this.cm.indexFromPos(this.cm.getCursor('head')) + offset
    return TextSelection.create(doc, anchor, head)
  }

  setSelection(anchor, head) {
    this.cm.focus()
    this.updating = true
    this.cm.setSelection(
      this.cm.posFromIndex(anchor),
      this.cm.posFromIndex(head)
    )
    this.updating = false
  }

  valueChanged() {
    const change = computeChange(this.node.textContent, this.cm.getValue())
    if (change) {
      const start = this.getPos() + 1
      const tr = this.view.state.tr.replaceWith(
        start + change.from,
        start + change.to,
        change.text ? this.schema.text(change.text) : null
      )
      this.view.dispatch(tr)
    }
  }

  codeMirrorKeymap() {
    const view = this.view
    const mod = /Mac/.test(navigator.platform) ? 'Cmd' : 'Ctrl'
    return CodeMirror.normalizeKeyMap({
      Up: () => this.maybeEscape('line', -1),
      Left: () => this.maybeEscape('char', -1),
      Down: () => this.maybeEscape('line', 1),
      Right: () => this.maybeEscape('char', 1),
      [`${mod}-Z`]: () => undo(view.state, view.dispatch),
      [`Shift-${mod}-Z`]: () => redo(view.state, view.dispatch),
      [`${mod}-Y`]: () => redo(view.state, view.dispatch),
      'Ctrl-Enter': () => {
        if (exitCode(view.state, view.dispatch)) view.focus()
      }
    })
  }

  maybeEscape(unit, dir) {
    const cursor = this.cm.getCursor()
    if (
      this.cm.somethingSelected() ||
      cursor.line != (dir < 0 ? this.cm.firstLine() : this.cm.lastLine()) ||
      (
        unit == 'char' &&
        cursor.ch != (dir < 0 ? 0 : this.cm.getLine(cursor.line).length)
      )
    ) {
      return CodeMirror.Pass
    }

    this.view.focus()
    const targetPos = this.getPos() + (dir < 0 ? 0 : this.node.nodeSize)
    const tr = this.view.state.tr
    let selection

    if (targetPos === 0) {
      tr.insert(0, this.schema.node('paragraph'))
      selection = new TextSelection(tr.doc.resolve(targetPos))
    } else {
      selection = Selection.near(this.view.state.doc.resolve(targetPos), dir)
    }

    tr.setSelection(selection).scrollIntoView()
    this.view.dispatch(tr)
    this.view.focus()
  }

  update(node, decorations) {
    this.updateOptions(decorations)
    this.updateLang(node)
    if (node.type != this.node.type) return false
    this.node = node
    const change = computeChange(this.cm.getValue(), node.textContent)
    if (change) {
      this.updating = true
      this.cm.replaceRange(
        change.text,
        this.cm.posFromIndex(change.from),
        this.cm.posFromIndex(change.to)
      )
      this.updating = false
    }
    return true
  }

  updateOptions(decorations) {
    if (decorations?.length) {
      decorations.forEach((deco) => {
        for (const key in deco.type.attrs) {
          this.cm.setOption(key, deco.type.attrs[key]);
        }

        this.cm.refresh()
      })
    }
  }

  updateLang(node) {
    const mode = modeByLang(node.attrs.params)
    const prev = this.cm.getOption('mode');
    if (mode !== prev) {
      this.cm.setOption('mode', mode)
    }
  }

  selectNode() {
    this.cm.focus()
  }

  stopEvent() {
    return true
  }
}

function computeChange(oldVal, newVal) {
  if (oldVal == newVal) return null
  let start = 0
  let oldEnd = oldVal.length
  let newEnd = newVal.length

  while (
    start < oldEnd &&
    oldVal.charCodeAt(start) == newVal.charCodeAt(start)
  ) {
    ++start
  }

  while (
    oldEnd > start &&
    newEnd > start &&
    oldVal.charCodeAt(oldEnd - 1) == newVal.charCodeAt(newEnd - 1)
  ) {
    oldEnd--
    newEnd--
  }

  return {
    from: start,
    to: oldEnd,
    text: newVal.slice(start, newEnd),
  }
}

function arrowHandler(dir) {
  return (state, dispatch, view) => {
    if (state.selection.empty && view.endOfTextblock(dir)) {
      const side = dir == 'left' || dir == 'up' ? -1 : 1
      const $head = state.selection.$head
      const nextPos = Selection.near(
        state.doc.resolve(side > 0 ? $head.after() : $head.before()),
        side
      )

      if (nextPos.$head?.parent.type.name == 'code_block') {
        dispatch(state.tr.setSelection(nextPos))
        return true
      }
    }
    return false
  }
}

const langMapping = {
  'c': 'text/x-csrc',
  'cpp': 'text/x-c++src',
  'c++': 'text/x-c++src',
  'objective-c': 'text/x-objectivec',
  'objc': 'text/x-objectivec',
  'scala': 'text/x-scala',
  'kotlin': 'text/x-kotlin',
  'ceylon': 'text/x-ceylon',
  'java': 'text/x-java',
  'js': 'javascript',
}

export const modeByLang = (lang: string) =>
  langMapping[lang] ? langMapping[lang] : lang

export const arrowHandlers = keymap({
  ArrowLeft: arrowHandler('left'),
  ArrowRight: arrowHandler('right'),
  ArrowUp: arrowHandler('up'),
  ArrowDown: arrowHandler('down')
})
